void Unicode2LCD(char *buf) // Конвентирует строку buf содержащую символы кириллицы в кодировке UNICODE в строку для вывода на LCD в кодировке экрана
                            // Важно: buf должен ссылаться на адрес ОЗУ МК. Если buf будет ссылаться на Flash, произойдет аварийный перезапуск МК
{
  uint8_t j = 0, k;

  for (uint8_t i = 0; buf[i] != 0;i++)
  {
    if(buf[i] == 0xD0) // Проверка на кириллицу в UNICODе.
    {
      i++; // Пропускаем символ 0xD0
      if(buf[i] == 0x81) // Проверяем букву 'Ё'
      {
        buf[j++] = BIG_YO;
        continue;
      }
      // Вычитаем из символа сивол кириллицы 'А' (0x90) и получаем индекс в массиве перекодировки.      
      k = constrain(buf[i] - 0x90, 0, sizeof(Char_Table) - 1); // Навсякий случай, что бы не вылететь за границу массива.
      buf[j++] = Char_Table[k]; 
      continue;
    }
    if(buf[i] == 0xD1) // Проверка на кириллицу в UNICODе.
    {
      i++; // Пропускаем символ 0xD1
      // Вычитаем из из символа сивол кириллицы 'р' (0x80), добавляем 48 и получаем индекс в массиве перекодировки.
      k = constrain(buf[i] + 48 - 0x80, 0, sizeof(Char_Table) - 1); // Навсякий случай, что бы не вылететь за границу массива.
      buf[j++] = Char_Table[k];                                                
      continue;
    }
    if(buf[i] > 0x7F) // Символы с номером больше чем 127 считаются записанными в кодировке UNICODE и имеют размер 2 байта. В этом случае если символ не попадает в диапазон кириллицы, оставляем его в строке без изменения.
    {
      if(i != j) // Если i == j то символ уже находится на своем месте в перекодируемой строке.
      {
        buf[j++] = buf[i++]; // Копируем 2 байта символа UNICODE без изменений.
        buf[j++] = buf[i];
      }
      else
      {
        i++; // Символ находится на своем месте 
        j += 2;
      }
    }
    else // Символ из первой половины таблицы ASCII и занимает 1 байт.
    {
      if(i != j)
        buf[j] = buf[i]; // Символ не в кодировке UNICODE, копируем его без изменений. Если i == j то символ уже находится на своем месте
      j++;
    }
  }
  buf[j] = 0; // Завершающий строку символ.
}